---
const { images = [], heroIndex = 0, class: extraClass = "" } = Astro.props;

/**
 * Normalize a variety of frontmatter image shapes into:
 * [{ src: string, alt: string }]
 *
 * Accepts:
 * - "/assets/..." (string)
 * - { src: "/assets/...", alt: "..." }
 * - { src: metadataObject, alt: "..." } // metadataObject has .src or .default
 * - { url: "/assets/...", alt: "..." }
 */
function normalize(input) {
  if (!input) return [];
  const list = Array.isArray(input) ? input : [input];

  return list
    .map((item) => {
      if (!item) return null;

      // Bare string path
      if (typeof item === "string") {
        return { src: item, alt: "" };
      }

      // If item has a src property
      if (typeof item === "object" && "src" in item) {
        const s = item.src;
        // If metadata object (import.meta.glob as metadata)
        if (s && typeof s === "object") {
          const resolved = s.src ?? s.default ?? "";
          return { src: resolved, alt: item.alt ?? item.caption ?? "" };
        }
        // Otherwise plain string src
        return { src: s ?? "", alt: item.alt ?? item.caption ?? "" };
      }

      // Fallback shapes: url / path
      if (typeof item === "object") {
        const src = item.url ?? item.path ?? item.src ?? "";
        return { src, alt: item.alt ?? item.caption ?? "" };
      }

      return null;
    })
    .filter(Boolean);
}

const imgs = normalize(images);

// Ensure we have at least an empty array to avoid runtime errors in the template
const safeImgs = Array.isArray(imgs) ? imgs : [];
const safeIndex =
  typeof heroIndex === "number" && heroIndex >= 0 && heroIndex < safeImgs.length
    ? heroIndex
    : 0;
---
<section class={`project-images-component ${extraClass}`} data-initial-index={safeIndex}>

  <style>
    :root {
      --pi-radius: 8px;
      --pi-border: #e6e6e6;
      --pi-shadow: 0 6px 18px rgba(16,24,40,0.06);
      --thumb-size: 76px;
      --gap: 0.6rem;
    }

    .project-images-component {
      margin-top: 1rem;
      max-width: 1100px;
      margin-left: auto;
      margin-right: auto;
    }

    .pi-viewer {
      display: flex;
      align-items: center;
      gap: var(--gap);
    }

    .pi-stage {
      flex: 1 1 auto;
      /* The stage size will be set dynamically to match the largest image in the set.
         Default to fluid constraints so things don't break before JS runs. */
      width: 100%;
      max-width: 100%;
      max-height: 80vh;
      background: #f8fafc;
      border-radius: var(--pi-radius);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--pi-border);
    }

    .pi-stage img {
        /* Let the image scale within the stage while preserving intrinsic aspect ratio.
           The stage element's width/height are computed from the largest image via JS. */
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
        transition: opacity 180ms ease;
    }

    .pi-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.6rem;
      justify-content: center;
    }

    .pi-btn {
      background: #fff;
      border: 1px solid var(--pi-border);
      padding: 0.35rem 0.6rem;
      border-radius: 6px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .pi-thumb-list {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }

    .pi-thumb {
      display: inline-block;
      width: var(--thumb-size);
      height: calc(var(--thumb-size) * 0.7);
      overflow: hidden;
      border-radius: 6px;
      border: 1px solid var(--pi-border);
      background: #fff;
      padding: 0;
      cursor: pointer;
    }

    .pi-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .pi-thumb[aria-selected="true"] {
      box-shadow: var(--pi-shadow);
      border-color: #cbd5e1;
    }

    @media (max-width: 720px) {
      .pi-stage { aspect-ratio: 4/3; }
      :root { --thumb-size: 60px; }
    }
  </style>

  <div class="pi-viewer" role="region" aria-label="Project images">
    <button class="pi-btn pi-prev" type="button" aria-label="Previous image" data-prev>‹</button>

    <div class="pi-stage" id="pi-stage">
      <!-- SSR: initial main image -->
      {
        safeImgs.length > 0 ? (
          <img
            id="pi-main-img"
            src={safeImgs[safeIndex].src}
            alt={safeImgs[safeIndex].alt ?? ""}
            loading="eager"
          />
        ) : (
          <div style="padding:2rem;color:#6b7280;">No images available</div>
        )
      }
    </div>

    <button class="pi-btn pi-next" type="button" aria-label="Next image" data-next>›</button>
  </div>

  <!-- Thumbnails (SSR rendered) -->
  <div class="pi-thumb-list" role="tablist" aria-label="Project thumbnails">
    {
      safeImgs.map((img, i) => (
        <button
          class="pi-thumb"
          type="button"
          data-index={i}
          aria-selected={i === safeIndex}
          aria-label={`Show image ${i + 1}`}
        >
          <!-- store the src on the img itself for easy client reading -->
          <img src={img.src} alt={img.alt ?? ""} loading="lazy" />
        </button>
      ))
    }
  </div>

  <div class="pi-controls" aria-hidden={safeImgs.length <= 1}>
    <div style="font-size:0.95rem;color:#6b7280;">
      {safeImgs.length > 0 ? `${safeIndex + 1} / ${safeImgs.length}` : ""}
    </div>
  </div>

  <script>
    (function () {
      // Defensive lookup for the component root (supports shadow/ownerDocument SSR cases)
      const root = document.currentScript && document.currentScript.ownerDocument
        ? document.currentScript.ownerDocument.querySelector('.project-images-component')
        : document.querySelector('.project-images-component');

      const container = root || document.querySelector('.project-images-component');
      if (!container) return;

      const main = container.querySelector('#pi-main-img');
      const thumbs = Array.from(container.querySelectorAll('.pi-thumb'));
      const prev = container.querySelector('[data-prev]');
      const next = container.querySelector('[data-next]');
      let active = Number(container.getAttribute('data-initial-index') || 0);

      // Build data array from thumbnails (SSR-provided)
      const data = thumbs.map(t => {
        const im = t.querySelector('img');
        return { src: im ? im.getAttribute('src') : '', alt: im ? im.getAttribute('alt') : '' };
      });

      // Apply a computed stage width/height so the stage matches the largest image
      function applyStageSize(naturalW, naturalH) {
        const stage = container.querySelector('#pi-stage');
        if (!stage || !naturalW || !naturalH) return;

        // Determine parent constraints (component has a max-width set in CSS)
        const parentWidth = Math.min(stage.parentElement ? stage.parentElement.clientWidth : Infinity, 1100);
        let targetW = Math.min(naturalW, parentWidth);
        let targetH = Math.round(naturalH * (targetW / naturalW));

        // Constrain by viewport height so it doesn't overflow
        const maxH = Math.round(window.innerHeight * 0.8);
        if (targetH > maxH) {
          targetH = maxH;
          targetW = Math.round(naturalW * (targetH / naturalH));
        }

        stage.style.width = targetW + 'px';
        stage.style.height = targetH + 'px';
      }

      // Preload all images to compute the largest natural size, then set the stage
      (function measureLargest() {
        if (!data || data.length === 0) {
          // nothing to do; still initialize UI
          return setActive(active);
        }

        let loaded = 0;
        let maxW = 0, maxH = 0;

        data.forEach(d => {
          const img = new Image();
          img.src = d.src;

          function finalizeIfDone() {
            loaded++;
            if (loaded === data.length) {
              if (maxW > 0 && maxH > 0) {
                applyStageSize(maxW, maxH);
              }
              setActive(active);
            }
          }

          if (img.complete && img.naturalWidth) {
            maxW = Math.max(maxW, img.naturalWidth || 0);
            maxH = Math.max(maxH, img.naturalHeight || 0);
            finalizeIfDone();
          } else {
            img.addEventListener('load', () => {
              maxW = Math.max(maxW, img.naturalWidth || 0);
              maxH = Math.max(maxH, img.naturalHeight || 0);
              finalizeIfDone();
            });
            img.addEventListener('error', () => {
              // skip broken image but still count it
              finalizeIfDone();
            });
          }
        });
      })();

      // Update main image and UI state
      function setActive(idx) {
        if (!data || data.length === 0) return;
        if (idx < 0) idx = data.length - 1;
        if (idx >= data.length) idx = 0;
        active = idx;

        // Update main image with a small fade
        if (main) {
          main.style.opacity = '0';
          setTimeout(() => {
            main.src = data[active].src;
            main.alt = data[active].alt || '';
            main.style.opacity = '1';
          }, 100);
        } else {
          // If no SSR main created, create one
          const stage = container.querySelector('#pi-stage');
          if (stage) {
            const img = document.createElement('img');
            img.id = 'pi-main-img';
            img.className = 'pi-main';
            img.src = data[active].src;
            img.alt = data[active].alt || '';
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100%';
            stage.innerHTML = '';
            stage.appendChild(img);
          }
        }

        // Update thumbs aria-selected and visibility
        thumbs.forEach((t, i) => {
          if (i === active) {
            t.setAttribute('aria-selected', 'true');
            t.classList.add('active');
            t.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
          } else {
            t.setAttribute('aria-selected', 'false');
            t.classList.remove('active');
          }
        });

        // Update counter area if present
        const counter = container.querySelector('.pi-controls > div');
        if (counter) counter.textContent = `${active + 1} / ${data.length}`;
      }

      // Wire thumbs
      thumbs.forEach((btn, i) => {
        btn.addEventListener('click', () => setActive(i));
        btn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            setActive(i);
          }
        });
      });

      // Prev/Next
      prev && prev.addEventListener('click', () => setActive(active - 1));
      next && next.addEventListener('click', () => setActive(active + 1));

      // Keyboard nav when focus inside component
      container.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          setActive(active - 1);
        } else if (e.key === 'ArrowRight') {
          setActive(active + 1);
        }
      });

      // Recompute stage size on window resize based on currently displayed image's natural size
      window.addEventListener('resize', () => {
        const current = data[active];
        if (!current) return;
        const probe = new Image();
        probe.src = current.src;
        probe.onload = () => applyStageSize(probe.naturalWidth || 0, probe.naturalHeight || 0);
      });

      // Also ensure initial keyboard/click state if JS runs after load
      window.addEventListener('load', () => setActive(active));
    })();
  </script>
</section>
